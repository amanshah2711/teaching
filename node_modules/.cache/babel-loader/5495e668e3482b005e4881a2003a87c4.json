{"ast":null,"code":"/**\n * Copyright (c) 2019, Chris Oakman\n * Copyright (c) 2019, Justin Fagnani\n * Released under the MIT license\n * https://github.com/justinfagnani/chessboard-element/blob/master/LICENSE.md\n */\nimport { isString, deepCopy } from './utils.js';\nconst RUN_ASSERTS = true;\nexport const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nexport const COLUMNS = 'abcdefgh'.split('');\nexport const whitePieces = ['wK', 'wQ', 'wR', 'wB', 'wN', 'wP'];\nexport const blackPieces = ['bK', 'bQ', 'bR', 'bB', 'bN', 'bP'];\nexport const getSquareColor = square => square.charCodeAt(0) % 2 ^ square.charCodeAt(1) % 2 ? 'white' : 'black';\nexport const validSquare = square => {\n  return isString(square) && square.search(/^[a-h][1-8]$/) !== -1;\n};\nexport const validMove = move => {\n  // move should be a string\n  if (!isString(move)) return false; // move should be in the form of \"e2-e4\", \"f6-d5\"\n\n  const squares = move.split('-');\n  if (squares.length !== 2) return false;\n  return validSquare(squares[0]) && validSquare(squares[1]);\n};\n\nif (RUN_ASSERTS) {\n  console.assert(validSquare('a1'));\n  console.assert(validSquare('e2'));\n  console.assert(!validSquare('D2'));\n  console.assert(!validSquare('g9'));\n  console.assert(!validSquare('a'));\n  console.assert(!validSquare(true));\n  console.assert(!validSquare(null));\n  console.assert(!validSquare({}));\n}\n\nexport const validPieceCode = code => {\n  return isString(code) && code.search(/^[bw][KQRNBP]$/) !== -1;\n};\n\nif (RUN_ASSERTS) {\n  console.assert(validPieceCode('bP'));\n  console.assert(validPieceCode('bK'));\n  console.assert(validPieceCode('wK'));\n  console.assert(validPieceCode('wR'));\n  console.assert(!validPieceCode('WR'));\n  console.assert(!validPieceCode('Wr'));\n  console.assert(!validPieceCode('a'));\n  console.assert(!validPieceCode(true));\n  console.assert(!validPieceCode(null));\n  console.assert(!validPieceCode({}));\n}\n\nconst squeezeFenEmptySquares = fen => {\n  return fen.replace(/11111111/g, '8').replace(/1111111/g, '7').replace(/111111/g, '6').replace(/11111/g, '5').replace(/1111/g, '4').replace(/111/g, '3').replace(/11/g, '2');\n};\n\nconst expandFenEmptySquares = fen => {\n  return fen.replace(/8/g, '11111111').replace(/7/g, '1111111').replace(/6/g, '111111').replace(/5/g, '11111').replace(/4/g, '1111').replace(/3/g, '111').replace(/2/g, '11');\n};\n\nexport const validFen = fen => {\n  if (!isString(fen)) return false; // cut off any move, castling, etc info from the end\n  // we're only interested in position information\n\n  fen = fen.replace(/ .+$/, ''); // expand the empty square numbers to just 1s\n\n  fen = expandFenEmptySquares(fen); // FEN should be 8 sections separated by slashes\n\n  const chunks = fen.split('/');\n  if (chunks.length !== 8) return false; // check each section\n\n  for (let i = 0; i < 8; i++) {\n    if (chunks[i].length !== 8 || chunks[i].search(/[^kqrnbpKQRNBP1]/) !== -1) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nif (RUN_ASSERTS) {\n  console.assert(validFen(START_FEN));\n  console.assert(validFen('8/8/8/8/8/8/8/8'));\n  console.assert(validFen('r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R'));\n  console.assert(validFen('3r3r/1p4pp/2nb1k2/pP3p2/8/PB2PN2/p4PPP/R4RK1 b - - 0 1'));\n  console.assert(!validFen('3r3z/1p4pp/2nb1k2/pP3p2/8/PB2PN2/p4PPP/R4RK1 b - - 0 1'));\n  console.assert(!validFen('anbqkbnr/8/8/8/8/8/PPPPPPPP/8'));\n  console.assert(!validFen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/'));\n  console.assert(!validFen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBN'));\n  console.assert(!validFen('888888/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR'));\n  console.assert(!validFen('888888/pppppppp/74/8/8/8/PPPPPPPP/RNBQKBNR'));\n  console.assert(!validFen({}));\n}\n\nexport const validPositionObject = pos => {\n  if (typeof pos !== 'object' || pos === null) {\n    return false;\n  }\n\n  for (const [square, piece] of Object.entries(pos)) {\n    if (!validSquare(square) || !validPieceCode(piece)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nif (RUN_ASSERTS) {\n  // console.assert(validPositionObject(START_POSITION));\n  console.assert(validPositionObject({}));\n  console.assert(validPositionObject({\n    e2: 'wP'\n  }));\n  console.assert(validPositionObject({\n    e2: 'wP',\n    d2: 'wP'\n  }));\n  console.assert(!validPositionObject({\n    e2: 'BP'\n  }));\n  console.assert(!validPositionObject({\n    y2: 'wP'\n  }));\n  console.assert(!validPositionObject(null));\n  console.assert(!validPositionObject(undefined));\n  console.assert(!validPositionObject(1));\n  console.assert(!validPositionObject('start'));\n  console.assert(!validPositionObject(START_FEN));\n} // convert FEN piece code to bP, wK, etc\n\n\nconst fenToPieceCode = piece => {\n  // black piece\n  if (piece.toLowerCase() === piece) {\n    return 'b' + piece.toUpperCase();\n  } // white piece\n\n\n  return 'w' + piece.toUpperCase();\n}; // convert bP, wK, etc code to FEN structure\n\n\nconst pieceCodeToFen = piece => {\n  const pieceCodeLetters = piece.split(''); // white piece\n\n  if (pieceCodeLetters[0] === 'w') {\n    return pieceCodeLetters[1].toUpperCase();\n  } // black piece\n\n\n  return pieceCodeLetters[1].toLowerCase();\n}; // convert FEN string to position object\n// returns false if the FEN string is invalid\n\n\nexport const fenToObj = fen => {\n  if (!validFen(fen)) return false; // cut off any move, castling, etc info from the end\n  // we're only interested in position information\n\n  fen = fen.replace(/ .+$/, '');\n  const rows = fen.split('/');\n  const position = {};\n  let currentRow = 8;\n\n  for (let i = 0; i < 8; i++) {\n    const row = rows[i].split('');\n    let colIdx = 0; // loop through each character in the FEN section\n\n    for (let j = 0; j < row.length; j++) {\n      // number / empty squares\n      if (row[j].search(/[1-8]/) !== -1) {\n        const numEmptySquares = parseInt(row[j], 10);\n        colIdx = colIdx + numEmptySquares;\n      } else {\n        // piece\n        const square = COLUMNS[colIdx] + currentRow;\n        position[square] = fenToPieceCode(row[j]);\n        colIdx = colIdx + 1;\n      }\n    }\n\n    currentRow = currentRow - 1;\n  }\n\n  return position;\n};\nexport const START_POSITION = fenToObj(START_FEN); // position object to FEN string\n// returns false if the obj is not a valid position object\n\nexport const objToFen = obj => {\n  if (!validPositionObject(obj)) return false;\n  let fen = '';\n  let currentRow = 8;\n\n  for (let i = 0; i < 8; i++) {\n    for (let j = 0; j < 8; j++) {\n      const square = COLUMNS[j] + currentRow; // piece exists\n\n      if (obj.hasOwnProperty(square)) {\n        fen = fen + pieceCodeToFen(obj[square]);\n      } else {\n        // empty space\n        fen = fen + '1';\n      }\n    }\n\n    if (i !== 7) {\n      fen = fen + '/';\n    }\n\n    currentRow = currentRow - 1;\n  } // squeeze the empty numbers together\n\n\n  fen = squeezeFenEmptySquares(fen);\n  return fen;\n};\n\nif (RUN_ASSERTS) {\n  console.assert(objToFen(START_POSITION) === START_FEN);\n  console.assert(objToFen({}) === '8/8/8/8/8/8/8/8');\n  console.assert(objToFen({\n    a2: 'wP',\n    b2: 'bP'\n  }) === '8/8/8/8/8/8/Pp6/8');\n}\n\nexport const normalizePozition = position => {\n  // start position\n  if (isString(position) && position.toLowerCase() === 'start') {\n    position = deepCopy(START_POSITION);\n  } // convert FEN to position object\n\n\n  if (validFen(position)) {\n    position = fenToObj(position);\n  }\n\n  return position;\n}; // returns the distance between two squares\n\nconst squareDistance = (squareA, squareB) => {\n  const squareAArray = squareA.split('');\n  const squareAx = COLUMNS.indexOf(squareAArray[0]) + 1;\n  const squareAy = parseInt(squareAArray[1], 10);\n  const squareBArray = squareB.split('');\n  const squareBx = COLUMNS.indexOf(squareBArray[0]) + 1;\n  const squareBy = parseInt(squareBArray[1], 10);\n  const xDelta = Math.abs(squareAx - squareBx);\n  const yDelta = Math.abs(squareAy - squareBy);\n  if (xDelta >= yDelta) return xDelta;\n  return yDelta;\n}; // returns an array of closest squares from square\n\n\nconst createRadius = square => {\n  const squares = []; // calculate distance of all squares\n\n  for (let i = 0; i < 8; i++) {\n    for (let j = 0; j < 8; j++) {\n      const s = COLUMNS[i] + (j + 1); // skip the square we're starting from\n\n      if (square === s) continue;\n      squares.push({\n        square: s,\n        distance: squareDistance(square, s)\n      });\n    }\n  } // sort by distance\n\n\n  squares.sort(function (a, b) {\n    return a.distance - b.distance;\n  }); // just return the square code\n\n  const surroundingSquares = [];\n\n  for (let i = 0; i < squares.length; i++) {\n    surroundingSquares.push(squares[i].square);\n  }\n\n  return surroundingSquares;\n}; // returns the square of the closest instance of piece\n// returns false if no instance of piece is found in position\n\n\nexport const findClosestPiece = (position, piece, square) => {\n  // create array of closest squares from square\n  const closestSquares = createRadius(square); // search through the position in order of distance for the piece\n\n  for (let i = 0; i < closestSquares.length; i++) {\n    const s = closestSquares[i];\n\n    if (position.hasOwnProperty(s) && position[s] === piece) {\n      return s;\n    }\n  }\n\n  return false;\n}; // given a position and a set of moves, return a new position\n// with the moves executed\n\nexport const calculatePositionFromMoves = (position, moves) => {\n  const newPosition = deepCopy(position);\n\n  for (const i in moves) {\n    if (!moves.hasOwnProperty(i)) continue; // skip the move if the position doesn't have a piece on the source square\n\n    if (!newPosition.hasOwnProperty(i)) continue;\n    const piece = newPosition[i];\n    delete newPosition[i];\n    newPosition[moves[i]] = piece;\n  }\n\n  return newPosition;\n}; // TODO: add some asserts here for calculatePositionFromMoves","map":{"version":3,"sources":["../src/lib/chess-utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Copyright (c) 2019, Chris Oakman\n * Copyright (c) 2019, Justin Fagnani\n * Released under the MIT license\n * https://github.com/justinfagnani/chessboard-element/blob/master/LICENSE.md\n */\nimport { isString, deepCopy } from './utils.js';\nconst RUN_ASSERTS = true;\nexport const START_FEN = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR';\nexport const COLUMNS = 'abcdefgh'.split('');\nexport const whitePieces = ['wK', 'wQ', 'wR', 'wB', 'wN', 'wP'];\nexport const blackPieces = ['bK', 'bQ', 'bR', 'bB', 'bN', 'bP'];\nexport const getSquareColor = (square) => square.charCodeAt(0) % 2 ^ square.charCodeAt(1) % 2 ? 'white' : 'black';\nexport const validSquare = (square) => {\n    return isString(square) && square.search(/^[a-h][1-8]$/) !== -1;\n};\nexport const validMove = (move) => {\n    // move should be a string\n    if (!isString(move))\n        return false;\n    // move should be in the form of \"e2-e4\", \"f6-d5\"\n    const squares = move.split('-');\n    if (squares.length !== 2)\n        return false;\n    return validSquare(squares[0]) && validSquare(squares[1]);\n};\nif (RUN_ASSERTS) {\n    console.assert(validSquare('a1'));\n    console.assert(validSquare('e2'));\n    console.assert(!validSquare('D2'));\n    console.assert(!validSquare('g9'));\n    console.assert(!validSquare('a'));\n    console.assert(!validSquare(true));\n    console.assert(!validSquare(null));\n    console.assert(!validSquare({}));\n}\nexport const validPieceCode = (code) => {\n    return isString(code) && code.search(/^[bw][KQRNBP]$/) !== -1;\n};\nif (RUN_ASSERTS) {\n    console.assert(validPieceCode('bP'));\n    console.assert(validPieceCode('bK'));\n    console.assert(validPieceCode('wK'));\n    console.assert(validPieceCode('wR'));\n    console.assert(!validPieceCode('WR'));\n    console.assert(!validPieceCode('Wr'));\n    console.assert(!validPieceCode('a'));\n    console.assert(!validPieceCode(true));\n    console.assert(!validPieceCode(null));\n    console.assert(!validPieceCode({}));\n}\nconst squeezeFenEmptySquares = (fen) => {\n    return fen\n        .replace(/11111111/g, '8')\n        .replace(/1111111/g, '7')\n        .replace(/111111/g, '6')\n        .replace(/11111/g, '5')\n        .replace(/1111/g, '4')\n        .replace(/111/g, '3')\n        .replace(/11/g, '2');\n};\nconst expandFenEmptySquares = (fen) => {\n    return fen\n        .replace(/8/g, '11111111')\n        .replace(/7/g, '1111111')\n        .replace(/6/g, '111111')\n        .replace(/5/g, '11111')\n        .replace(/4/g, '1111')\n        .replace(/3/g, '111')\n        .replace(/2/g, '11');\n};\nexport const validFen = (fen) => {\n    if (!isString(fen))\n        return false;\n    // cut off any move, castling, etc info from the end\n    // we're only interested in position information\n    fen = fen.replace(/ .+$/, '');\n    // expand the empty square numbers to just 1s\n    fen = expandFenEmptySquares(fen);\n    // FEN should be 8 sections separated by slashes\n    const chunks = fen.split('/');\n    if (chunks.length !== 8)\n        return false;\n    // check each section\n    for (let i = 0; i < 8; i++) {\n        if (chunks[i].length !== 8 || chunks[i].search(/[^kqrnbpKQRNBP1]/) !== -1) {\n            return false;\n        }\n    }\n    return true;\n};\nif (RUN_ASSERTS) {\n    console.assert(validFen(START_FEN));\n    console.assert(validFen('8/8/8/8/8/8/8/8'));\n    console.assert(validFen('r1bqkbnr/pppp1ppp/2n5/1B2p3/4P3/5N2/PPPP1PPP/RNBQK2R'));\n    console.assert(validFen('3r3r/1p4pp/2nb1k2/pP3p2/8/PB2PN2/p4PPP/R4RK1 b - - 0 1'));\n    console.assert(!validFen('3r3z/1p4pp/2nb1k2/pP3p2/8/PB2PN2/p4PPP/R4RK1 b - - 0 1'));\n    console.assert(!validFen('anbqkbnr/8/8/8/8/8/PPPPPPPP/8'));\n    console.assert(!validFen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/'));\n    console.assert(!validFen('rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBN'));\n    console.assert(!validFen('888888/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR'));\n    console.assert(!validFen('888888/pppppppp/74/8/8/8/PPPPPPPP/RNBQKBNR'));\n    console.assert(!validFen({}));\n}\nexport const validPositionObject = (pos) => {\n    if (typeof pos !== 'object' || pos === null) {\n        return false;\n    }\n    for (const [square, piece] of Object.entries(pos)) {\n        if (!validSquare(square) || !validPieceCode(piece)) {\n            return false;\n        }\n    }\n    return true;\n};\nif (RUN_ASSERTS) {\n    // console.assert(validPositionObject(START_POSITION));\n    console.assert(validPositionObject({}));\n    console.assert(validPositionObject({ e2: 'wP' }));\n    console.assert(validPositionObject({ e2: 'wP', d2: 'wP' }));\n    console.assert(!validPositionObject({ e2: 'BP' }));\n    console.assert(!validPositionObject({ y2: 'wP' }));\n    console.assert(!validPositionObject(null));\n    console.assert(!validPositionObject(undefined));\n    console.assert(!validPositionObject(1));\n    console.assert(!validPositionObject('start'));\n    console.assert(!validPositionObject(START_FEN));\n}\n// convert FEN piece code to bP, wK, etc\nconst fenToPieceCode = (piece) => {\n    // black piece\n    if (piece.toLowerCase() === piece) {\n        return 'b' + piece.toUpperCase();\n    }\n    // white piece\n    return 'w' + piece.toUpperCase();\n};\n// convert bP, wK, etc code to FEN structure\nconst pieceCodeToFen = (piece) => {\n    const pieceCodeLetters = piece.split('');\n    // white piece\n    if (pieceCodeLetters[0] === 'w') {\n        return pieceCodeLetters[1].toUpperCase();\n    }\n    // black piece\n    return pieceCodeLetters[1].toLowerCase();\n};\n// convert FEN string to position object\n// returns false if the FEN string is invalid\nexport const fenToObj = (fen) => {\n    if (!validFen(fen))\n        return false;\n    // cut off any move, castling, etc info from the end\n    // we're only interested in position information\n    fen = fen.replace(/ .+$/, '');\n    const rows = fen.split('/');\n    const position = {};\n    let currentRow = 8;\n    for (let i = 0; i < 8; i++) {\n        const row = rows[i].split('');\n        let colIdx = 0;\n        // loop through each character in the FEN section\n        for (let j = 0; j < row.length; j++) {\n            // number / empty squares\n            if (row[j].search(/[1-8]/) !== -1) {\n                const numEmptySquares = parseInt(row[j], 10);\n                colIdx = colIdx + numEmptySquares;\n            }\n            else {\n                // piece\n                const square = COLUMNS[colIdx] + currentRow;\n                position[square] = fenToPieceCode(row[j]);\n                colIdx = colIdx + 1;\n            }\n        }\n        currentRow = currentRow - 1;\n    }\n    return position;\n};\nexport const START_POSITION = fenToObj(START_FEN);\n// position object to FEN string\n// returns false if the obj is not a valid position object\nexport const objToFen = (obj) => {\n    if (!validPositionObject(obj))\n        return false;\n    let fen = '';\n    let currentRow = 8;\n    for (let i = 0; i < 8; i++) {\n        for (let j = 0; j < 8; j++) {\n            const square = COLUMNS[j] + currentRow;\n            // piece exists\n            if (obj.hasOwnProperty(square)) {\n                fen = fen + pieceCodeToFen(obj[square]);\n            }\n            else {\n                // empty space\n                fen = fen + '1';\n            }\n        }\n        if (i !== 7) {\n            fen = fen + '/';\n        }\n        currentRow = currentRow - 1;\n    }\n    // squeeze the empty numbers together\n    fen = squeezeFenEmptySquares(fen);\n    return fen;\n};\nif (RUN_ASSERTS) {\n    console.assert(objToFen(START_POSITION) === START_FEN);\n    console.assert(objToFen({}) === '8/8/8/8/8/8/8/8');\n    console.assert(objToFen({ a2: 'wP', b2: 'bP' }) === '8/8/8/8/8/8/Pp6/8');\n}\nexport const normalizePozition = (position) => {\n    // start position\n    if (isString(position) && position.toLowerCase() === 'start') {\n        position = deepCopy(START_POSITION);\n    }\n    // convert FEN to position object\n    if (validFen(position)) {\n        position = fenToObj(position);\n    }\n    return position;\n};\n// returns the distance between two squares\nconst squareDistance = (squareA, squareB) => {\n    const squareAArray = squareA.split('');\n    const squareAx = COLUMNS.indexOf(squareAArray[0]) + 1;\n    const squareAy = parseInt(squareAArray[1], 10);\n    const squareBArray = squareB.split('');\n    const squareBx = COLUMNS.indexOf(squareBArray[0]) + 1;\n    const squareBy = parseInt(squareBArray[1], 10);\n    const xDelta = Math.abs(squareAx - squareBx);\n    const yDelta = Math.abs(squareAy - squareBy);\n    if (xDelta >= yDelta)\n        return xDelta;\n    return yDelta;\n};\n// returns an array of closest squares from square\nconst createRadius = (square) => {\n    const squares = [];\n    // calculate distance of all squares\n    for (let i = 0; i < 8; i++) {\n        for (let j = 0; j < 8; j++) {\n            const s = COLUMNS[i] + (j + 1);\n            // skip the square we're starting from\n            if (square === s)\n                continue;\n            squares.push({\n                square: s,\n                distance: squareDistance(square, s),\n            });\n        }\n    }\n    // sort by distance\n    squares.sort(function (a, b) {\n        return a.distance - b.distance;\n    });\n    // just return the square code\n    const surroundingSquares = [];\n    for (let i = 0; i < squares.length; i++) {\n        surroundingSquares.push(squares[i].square);\n    }\n    return surroundingSquares;\n};\n// returns the square of the closest instance of piece\n// returns false if no instance of piece is found in position\nexport const findClosestPiece = (position, piece, square) => {\n    // create array of closest squares from square\n    const closestSquares = createRadius(square);\n    // search through the position in order of distance for the piece\n    for (let i = 0; i < closestSquares.length; i++) {\n        const s = closestSquares[i];\n        if (position.hasOwnProperty(s) && position[s] === piece) {\n            return s;\n        }\n    }\n    return false;\n};\n// given a position and a set of moves, return a new position\n// with the moves executed\nexport const calculatePositionFromMoves = (position, moves) => {\n    const newPosition = deepCopy(position);\n    for (const i in moves) {\n        if (!moves.hasOwnProperty(i))\n            continue;\n        // skip the move if the position doesn't have a piece on the source square\n        if (!newPosition.hasOwnProperty(i))\n            continue;\n        const piece = newPosition[i];\n        delete newPosition[i];\n        newPosition[moves[i]] = piece;\n    }\n    return newPosition;\n};\n// TODO: add some asserts here for calculatePositionFromMoves\n//# sourceMappingURL=chess-utils.js.map"]},"metadata":{},"sourceType":"module"}